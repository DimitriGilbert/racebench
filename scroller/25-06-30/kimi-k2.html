<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kimi K2 - LiteChat Race Result</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #f0f2f5; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-button { transition: all 0.2s ease-in-out; border-bottom: 2px solid transparent; }
        .tab-button.active { border-bottom-color: #6366f1; color: #4f46e5; background-color: #e0e7ff; }
        .dark .tab-button.active { border-bottom-color: #818cf8; color: #a5b4fc; background-color: #374151; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 p-4 sm:p-6 md:p-8">
    <div class="max-w-7xl mx-auto container bg-white dark:bg-gray-800 rounded-2xl shadow-lg overflow-hidden">
        <div class="header bg-gradient-to-r from-violet-600 to-indigo-600 text-white p-6 sm:p-8 text-center">
            <h1 class="text-3xl sm:text-4xl font-bold mb-2">üöÄ Kimi K2</h1>
            <p class="text-indigo-200">LiteChat Race Result</p>
        </div>
        
        <div class="p-4 sm:p-6">
            <div class="border-b border-gray-200 dark:border-gray-700 mb-4">
                <nav class="-mb-px flex space-x-4" aria-label="Tabs">
                    <button class="tab-button active text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 whitespace-nowrap py-3 px-4 font-medium text-sm rounded-t-md" data-tab="preview">Live Preview</button>
                    <button class="tab-button text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 whitespace-nowrap py-3 px-4 font-medium text-sm rounded-t-md" data-tab="raw">Raw Response</button>
                </nav>
            </div>

            <div id="preview" class="tab-content active">
                <div id="litechat-target" class="w-full min-h-[600px] bg-gray-50 dark:bg-gray-700/50 rounded-lg p-4 border border-gray-200 dark:border-gray-600"></div>
            </div>

            <div id="raw" class="tab-content">
                <div class="w-full min-h-[600px] bg-gray-900 text-white rounded-lg p-4 overflow-x-auto font-mono">
                    <pre class="whitespace-pre-wrap text-sm"><code>I'll create a colorful 2D scroll shooter with 3D effects using Three.js! This will have a comfy game area with all the bonuses you requested.

                      ```runjs
                      // Clear any previous content
                      litechat.target.replaceChildren();
                      
                      async function createScrollShooter() {
                          try {
                              litechat.utils.log('info', 'üöÄ Starting 2D Scroll Shooter creation...');
                              
                              // Load Three.js
                              const modules = await litechat.utils.loadModules([
                                  {
                                      url: 'https://unpkg.com/three@0.170.0/build/three.module.js',
                                      name: 'THREE',
                                      globalKey: 'THREE',
                                      importMap: {
                                          "three": "https://unpkg.com/three@0.170.0/build/three.module.js"
                                      }
                                  }
                              ]);
                      
                              const { THREE } = modules;
                              
                              // Create game container
                              const gameContainer = document.createElement('div');
                              gameContainer.className = 'p-4 bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 rounded-xl shadow-2xl max-w-4xl mx-auto';
                              
                              const canvas = document.createElement('canvas');
                              canvas.width = 800;
                              canvas.height = 600;
                              canvas.className = 'border-2 border-purple-400 rounded-lg shadow-lg';
                              gameContainer.appendChild(canvas);
                              
                              // Add UI overlay
                              const uiOverlay = document.createElement('div');
                              uiOverlay.className = 'absolute top-4 left-4 text-white font-bold text-lg';
                              uiOverlay.innerHTML = `
                                  <div class="bg-black/50 p-3 rounded-lg">
                                      <div>‚ù§Ô∏è Lives: <span id="lives">3</span></div>
                                      <div>üî´ Fire Rate: <span id="fireRate">100%</span></div>
                                      <div>üí• Bouncy: <span id="bouncy">0</span></div>
                                      <div>üî´ Guns: <span id="guns">1</span></div>
                                  </div>
                              `;
                              gameContainer.appendChild(uiOverlay);
                              
                              litechat.target.appendChild(gameContainer);
                      
                              // Three.js setup
                              const scene = new THREE.Scene();
                              scene.background = new THREE.Color(0x0a0a2a);
                              
                              const camera = new THREE.OrthographicCamera(-400, 400, 300, -300, 1, 1000);
                              camera.position.z = 500;
                              
                              const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
                              renderer.setSize(800, 600);
                              renderer.shadowMap.enabled = true;
                      
                              // Game state
                              let gameState = {
                                  lives: 3,
                                  fireRate: 1.0,
                                  bouncyLevel: 0,
                                  gunLevel: 1,
                                  score: 0,
                                  wave: 1,
                                  keys: {},
                                  lastShot: 0
                              };
                      
                              // Game objects
                              const player = {
                                  x: 0,
                                  y: -250,
                                  width: 40,
                                  height: 40,
                                  speed: 5,
                                  mesh: null
                              };
                      
                              const bullets = [];
                              const enemies = [];
                              const bonuses = [];
                              const particles = [];
                      
                              // Create player mesh
                              const playerGeometry = new THREE.BoxGeometry(40, 40, 10);
                              const playerMaterial = new THREE.MeshLambertMaterial({ 
                                  color: 0x00ff88,
                                  emissive: 0x00ff88,
                                  emissiveIntensity: 0.3
                              });
                              player.mesh = new THREE.Mesh(playerGeometry, playerMaterial);
                              player.mesh.position.set(player.x, player.y, 0);
                              scene.add(player.mesh);
                      
                              // Add lights
                              const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                              scene.add(ambientLight);
                              
                              const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                              directionalLight.position.set(0, 0, 100);
                              scene.add(directionalLight);
                      
                              // Create background stars
                              const starGeometry = new THREE.BufferGeometry();
                              const starCount = 200;
                              const starPositions = new Float32Array(starCount * 3);
                              
                              for (let i = 0; i < starCount * 3; i += 3) {
                                  starPositions[i] = (Math.random() - 0.5) * 1000;
                                  starPositions[i + 1] = (Math.random() - 0.5) * 1000;
                                  starPositions[i + 2] = -100 - Math.random() * 400;
                              }
                              
                              starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
                              const starMaterial = new THREE.PointsMaterial({ 
                                  color: 0xffffff, 
                                  size: 2,
                                  transparent: true,
                                  opacity: 0.8
                              });
                              const stars = new THREE.Points(starGeometry, starMaterial);
                              scene.add(stars);
                      
                              // Helper functions
                              function createBullet(x, y, dx, dy, bouncy = false) {
                                  const geometry = new THREE.SphereGeometry(5, 8, 8);
                                  const material = new THREE.MeshLambertMaterial({ 
                                      color: bouncy ? 0xff00ff : 0x00ffff,
                                      emissive: bouncy ? 0xff00ff : 0x00ffff,
                                      emissiveIntensity: 0.5
                                  });
                                  const mesh = new THREE.Mesh(geometry, material);
                                  mesh.position.set(x, y, 10);
                                  scene.add(mesh);
                                  
                                  bullets.push({
                                      x, y, dx, dy, mesh, bouncy, bounces: 0
                                  });
                              }
                      
                              function createEnemy(x, y, speed) {
                                  const colors = [0xff4444, 0xff8844, 0xffff44, 0x44ff44, 0x44ffff, 0x8844ff];
                                  const color = colors[Math.floor(Math.random() * colors.length)];
                                  
                                  const geometry = new THREE.BoxGeometry(30, 30, 15);
                                  const material = new THREE.MeshLambertMaterial({ 
                                      color: color,
                                      emissive: color,
                                      emissiveIntensity: 0.2
                                  });
                                  const mesh = new THREE.Mesh(geometry, material);
                                  mesh.position.set(x, y, 0);
                                  scene.add(mesh);
                                  
                                  enemies.push({
                                      x, y, speed, mesh, health: gameState.wave
                                  });
                              }
                      
                              function createBonus(x, y, type) {
                                  const colors = {
                                      fireRate: 0xff8800,
                                      bouncy: 0xff00ff,
                                      gun: 0x00ff00,
                                      life: 0xff0000
                                  };
                                  
                                  const icons = {
                                      fireRate: '‚ö°',
                                      bouncy: 'üí•',
                                      gun: 'üî´',
                                      life: '‚ù§Ô∏è'
                                  };
                                  
                                  const geometry = new THREE.SphereGeometry(15, 8, 8);
                                  const material = new THREE.MeshLambertMaterial({ 
                                      color: colors[type],
                                      emissive: colors[type],
                                      emissiveIntensity: 0.4
                                  });
                                  const mesh = new THREE.Mesh(geometry, material);
                                  mesh.position.set(x, y, 5);
                                  scene.add(mesh);
                                  
                                  bonuses.push({
                                      x, y, type, mesh
                                  });
                              }
                      
                              function createParticle(x, y, color) {
                                  const geometry = new THREE.SphereGeometry(3, 4, 4);
                                  const material = new THREE.MeshBasicMaterial({ color });
                                  const mesh = new THREE.Mesh(geometry, material);
                                  mesh.position.set(x, y, 20);
                                  scene.add(mesh);
                                  
                                  particles.push({
                                      x, y, dx: (Math.random() - 0.5) * 10,
                                      dy: (Math.random() - 0.5) * 10,
                                      life: 30, mesh
                                  });
                              }
                      
                              function updateUI() {
                                  document.getElementById('lives').textContent = gameState.lives;
                                  document.getElementById('fireRate').textContent = Math.round(gameState.fireRate * 100) + '%';
                                  document.getElementById('bouncy').textContent = gameState.bouncyLevel;
                                  document.getElementById('guns').textContent = gameState.gunLevel;
                              }
                      
                              // Input handling
                              document.addEventListener('keydown', (e) => {
                                  gameState.keys[e.key.toLowerCase()] = true;
                              });
                      
                              document.addEventListener('keyup', (e) => {
                                  gameState.keys[e.key.toLowerCase()] = false;
                              });
                      
                              // Game loop
                              let lastEnemySpawn = 0;
                              let lastBonusSpawn = 0;
                      
                              function gameLoop() {
                                  const now = Date.now();
                                  
                                  // Move player
                                  if (gameState.keys['arrowleft'] && player.x > -380) player.x -= player.speed;
                                  if (gameState.keys['arrowright'] && player.x < 380) player.x += player.speed;
                                  if (gameState.keys['arrowup'] && player.y > -280) player.y -= player.speed;
                                  if (gameState.keys['arrowdown'] && player.y < 280) player.y += player.speed;
                                  
                                  player.mesh.position.set(player.x, player.y, 0);
                                  
                                  // Shoot bullets
                                  const shootInterval = 300 / gameState.fireRate;
                                  if (gameState.keys[' '] && now - gameState.lastShot > shootInterval) {
                                      const offsets = {
                                          1: [[0, 20]],
                                          2: [[-15, 20], [15, 20]],
                                          3: [[-20, 20], [0, 25], [20, 20]]
                                      };
                                      
                                      offsets[gameState.gunLevel].forEach(([dx, dy]) => {
                                          createBullet(
                                              player.x + dx,
                                              player.y + dy,
                                              0, 8,
                                              gameState.bouncyLevel > 0
                                          );
                                      });
                                      
                                      gameState.lastShot = now;
                                  }
                                  
                                  // Update bullets
                                  bullets.forEach((bullet, index) => {
                                      bullet.x += bullet.dx;
                                      bullet.y += bullet.dy;
                                      bullet.mesh.position.set(bullet.x, bullet.y, 10);
                                      
                                      if (bullet.y > 350) {
                                          scene.remove(bullet.mesh);
                                          bullets.splice(index, 1);
                                      }
                                  });
                                  
                                  // Spawn enemies
                                  if (now - lastEnemySpawn > 2000 / Math.sqrt(gameState.wave)) {
                                      createEnemy(
                                          (Math.random() - 0.5) * 700,
                                          350,
                                          2 + gameState.wave * 0.5
                                      );
                                      lastEnemySpawn = now;
                                  }
                                  
                                  // Spawn bonuses
                                  if (now - lastBonusSpawn > 8000) {
                                      const types = ['fireRate', 'bouncy', 'gun', 'life'];
                                      const type = types[Math.floor(Math.random() * types.length)];
                                      createBonus(
                                          (Math.random() - 0.5) * 700,
                                          Math.random() * 400 - 200,
                                          type
                                      );
                                      lastBonusSpawn = now;
                                  }
                                  
                                  // Update enemies
                                  enemies.forEach((enemy, enemyIndex) => {
                                      enemy.y -= enemy.speed;
                                      enemy.mesh.position.set(enemy.x, enemy.y, 0);
                                      
                                      // Check collision with player
                                      if (Math.abs(enemy.x - player.x) < 35 && Math.abs(enemy.y - player.y) < 35) {
                                          gameState.lives--;
                                          updateUI();
                                          
                                          for (let i = 0; i < 10; i++) {
                                              createParticle(enemy.x, enemy.y, 0xff0000);
                                          }
                                          
                                          scene.remove(enemy.mesh);
                                          enemies.splice(enemyIndex, 1);
                                          
                                          if (gameState.lives <= 0) {
                                              alert('Game Over! Refresh to play again.');
                                              return;
                                          }
                                      }
                                      
                                      if (enemy.y < -350) {
                                          scene.remove(enemy.mesh);
                                          enemies.splice(enemyIndex, 1);
                                      }
                                  });
                                  
                                  // Update bonuses
                                  bonuses.forEach((bonus, index) => {
                                      bonus.y -= 1;
                                      bonus.mesh.position.set(bonus.x, bonus.y, 5);
                                      bonus.mesh.rotation.y += 0.05;
                                      
                                      // Check collision with player
                                      if (Math.abs(bonus.x - player.x) < 30 && Math.abs(bonus.y - player.y) < 30) {
                                          switch (bonus.type) {
                                              case 'fireRate':
                                                  gameState.fireRate = Math.min(gameState.fireRate * 1.1, 5);
                                                  break;
                                              case 'bouncy':
                                                  gameState.bouncyLevel++;
                                                  break;
                                              case 'gun':
                                                  gameState.gunLevel = Math.min(gameState.gunLevel + 1, 3);
                                                  break;
                                              case 'life':
                                                  gameState.lives++;
                                                  break;
                                          }
                                          
                                          updateUI();
                                          
                                          for (let i = 0; i < 8; i++) {
                                              createParticle(bonus.x, bonus.y, 0xffff00);
                                          }
                                          
                                          scene.remove(bonus.mesh);
                                          bonuses.splice(index, 1);
                                      }
                                      
                                      if (bonus.y < -350) {
                                          scene.remove(bonus.mesh);
                                          bonuses.splice(index, 1);
                                      }
                                  });
                                  
                                  // Update particles
                                  particles.forEach((particle, index) => {
                                      particle.x += particle.dx;
                                      particle.y += particle.dy;
                                      particle.dx *= 0.98;
                                      particle.dy *= 0.98;
                                      particle.mesh.position.set(particle.x, particle.y, 20);
                                      particle.life--;
                                      
                                      if (particle.life <= 0) {
                                          scene.remove(particle.mesh);
                                          particles.splice(index, 1);
                                      }
                                  });
                                  
                                  // Check bullet-enemy collisions
                                  bullets.forEach((bullet, bulletIndex) => {
                                      enemies.forEach((enemy, enemyIndex) => {
                                          if (Math.abs(bullet.x - enemy.x) < 20 && Math.abs(bullet.y - enemy.y) < 20) {
                                              enemy.health--;
                                              
                                              if (enemy.health <= 0) {
                                                  for (let i = 0; i < 8; i++) {
                                                      createParticle(enemy.x, enemy.y, enemy.mesh.material.color.getHex());
                                                  }
                                                  
                                                  scene.remove(enemy.mesh);
                                                  enemies.splice(enemyIndex, 1);
                                                  gameState.score += 10;
                                                  
                                                  // Bouncy bullet logic
                                                  if (bullet.bouncy && bullet.bounces < gameState.bouncyLevel) {
                                                      bullet.bounces++;
                                                      bullet.dx = (Math.random() - 0.5) * 8;
                                                      bullet.dy = -Math.abs(bullet.dy);
                                                      return;
                                                  }
                                              }
                                              
                                              scene.remove(bullet.mesh);
                                              bullets.splice(bulletIndex, 1);
                                          }
                                      });
                                  });
                                  
                                  // Update wave
                                  if (enemies.length === 0 && now - lastEnemySpawn > 5000) {
                                      gameState.wave++;
                                  }
                                  
                                  // Animate stars
                                  stars.rotation.y += 0.0005;
                                  
                                  renderer.render(scene, camera);
                                  requestAnimationFrame(gameLoop);
                              }
                              
                              updateUI();
                              gameLoop();
                              
                              // Instructions
                              const instructions = document.createElement('div');
                              instructions.className = 'text-center text-white mt-4 text-sm';
                              instructions.innerHTML = `
                                  Use ARROW KEYS to move ‚Ä¢ SPACE to shoot ‚Ä¢ Collect colorful bonuses!<br>
                                  Red = Extra Life ‚Ä¢ Orange = Faster Fire ‚Ä¢ Purple = Bouncy Bullets ‚Ä¢ Green = More Guns
                              `;
                              gameContainer.appendChild(instructions);
                              
                              litechat.utils.log('info', 'üéÆ Game started! Use arrow keys to move and space to shoot');
                              
                          } catch (error) {
                              litechat.utils.log('error', '‚ùå Failed to create game:', error.message);
                          }
                      }
                      
                      createScrollShooter();
                      ```
                      
                      I've created a vibrant 2D scroll shooter with 3D effects using Three.js! Here's what I've built:
                      
                      **üéÆ Game Features:**
                      - **Comfy game area** with a soothing purple-blue gradient background and twinkling 3D stars
                      - **Colorful 3D graphics** with glowing effects and particle explosions
                      - **Smooth controls** with arrow keys for movement and spacebar to shoot
                      
                      **üíé Bonus System:**
                      - **‚ö° Faster Fire Rate** (Orange): Increases shooting speed by 10% each time
                      - **üí• Bouncy Fire** (Purple): Bullets bounce off destroyed enemies (number of bounces = bonus count)
                      - **üî´ More Guns** (Green): Weapon upgrades from 1 ‚Üí 2 (left/right) ‚Üí 3 (spread pattern)
                      - **‚ù§Ô∏è Extra Life** (Red): Adds one life
                      
                      **üëæ Enemy System:**
                      - Enemies spawn faster and get stronger with each wave
                      - Colorful enemies with increasing health based on wave number
                      - Collision detection with visual feedback
                      
                      **üé® Visual Effects:**
                      - 3D perspective with depth
                      - Glowing neon colors
                      - Particle explosions on destruction
                      - Smooth animations and rotations
                      - Animated background stars
                      
                      **üìä Live UI:**
                      - Real-time display of lives, fire rate, bouncy level, and gun count
                      - Updated dynamically as you collect bonuses
                      
                      The game has a cozy, arcade-like feel with bright, popping colors and smooth 3D effects. Enjoy defending against the colorful enemy waves!</code></pre>
                </div>
            </div>
        </div>

        <div class="footer bg-gray-50 dark:bg-gray-800/50 p-4 border-t border-gray-200 dark:border-gray-700 text-center text-sm text-gray-500 dark:text-gray-400">
            Generated by <strong>LiteChat</strong> ‚Ä¢ <a href="./index.html" class="text-indigo-600 dark:text-indigo-400 hover:underline">Back to Main Page</a>
        </div>
    </div>
    <script type="module">
        // LiteChat API Implementation
        const litechatTarget = document.getElementById('litechat-target');
        const capturedLogs = [];

        // Enhanced module loading with import map support
        async function loadModule(moduleUrl, moduleName, globalKey, importMap) {
            const key = globalKey || moduleName;
            // Check if already loaded
            if (window[key]) {
                return window[key];
            }

            try {
                // Setup import map if provided
                if (importMap) {
                    // Remove any existing import map first
                    const existingMap = document.querySelector('script[type="importmap"]');
                    if (existingMap) {
                        existingMap.remove();
                    }

                    const mapScript = document.createElement('script');
                    mapScript.type = 'importmap';
                    mapScript.textContent = JSON.stringify({ imports: importMap });
                    document.head.appendChild(mapScript);

                    // Wait for the import map to be processed
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                // Dynamic import
                const module = await import(moduleUrl);
                window[key] = module;

                // Dispatch ready event
                window.dispatchEvent(new CustomEvent(`${moduleName.toLowerCase()}-ready`, {
                    detail: { [moduleName]: module }
                }));

                return module;
            } catch (error) {
                console.error(`Error loading module ${moduleName}:`, error);
                window.dispatchEvent(new CustomEvent(`${moduleName.toLowerCase()}-error`, {
                    detail: error
                }));
                throw error;
            }
        }

        // Enhanced loadModules function
        async function loadModules(moduleConfigs) {
            const loadedModules = {};
            const loadPromises = {};

            // 1. Merge all import maps from module configs
            const globalImportMap = {};
            moduleConfigs.forEach(config => {
                if (config.importMap) {
                    Object.assign(globalImportMap, config.importMap);
                }
            });

            // 2. Remove any existing import map
            const existingMap = document.querySelector('script[type="importmap"]');
            if (existingMap) existingMap.remove();

            // 3. Inject the new import map
            if (Object.keys(globalImportMap).length > 0) {
                const mapScript = document.createElement('script');
                mapScript.type = 'importmap';
                mapScript.textContent = JSON.stringify({ imports: globalImportMap });
                document.head.appendChild(mapScript);

                // 4. Wait for the import map to be processed
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            // 5. Helper function to load a single module
            const loadSingleModule = async (config) => {
                const key = config.globalKey || config.name;
                if (window[key]) return window[key];
                if (key in loadPromises) return loadPromises[key];

                // Wait for dependencies first
                if (config.dependencies) {
                    await Promise.all(config.dependencies.map(depKey => {
                        const depModule = moduleConfigs.find(m => (m.globalKey || m.name) === depKey);
                        if (depModule) return loadSingleModule(depModule);
                        return Promise.resolve();
                    }));
                }

                // Load the module
                loadPromises[key] = (async () => {
                    try {
                        const module = await import(config.url);
                        window[key] = module;
                        loadedModules[key] = module;
                        return module;
                    } catch (error) {
                        console.error(`Error loading module ${config.name}:`, error);
                        throw error;
                    }
                })();

                return loadPromises[key];
            };

            // 6. Load all modules
            await Promise.all(moduleConfigs.map(config => loadSingleModule(config)));

            return loadedModules;
        }

        // Load script function
        async function loadScript(src) {
            return new Promise((resolve, reject) => {
                // Check if already loaded
                if ([...document.scripts].some(s => s.src === src)) {
                    resolve();
                    return;
                }
                const script = document.createElement('script');
                script.src = src;
                script.async = true;
                script.onload = () => resolve();
                script.onerror = (e) => {
                    const errorMessage = e instanceof Error ? e.message : String(e);
                    reject(new Error(`Failed to load script: ${src} - ${errorMessage}`));
                };
                document.head.appendChild(script);
            });
        }

        // Toast function (simple alert fallback)
        function showToast(message) {
            // Create a simple toast notification
            const toast = document.createElement('div');
            toast.className = 'fixed top-4 right-4 bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-all duration-300';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateY(-20px)';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }, 3000);
        }

        // LiteChat API object
        window.litechat = {
            utils: {
                log: (...args) => {
                    const formatted = args.map(arg => 
                        typeof arg === "object" ? JSON.stringify(arg) : String(arg)
                    ).join(" ");
                    capturedLogs.push(formatted);
                    console.log(...args);
                },
                toast: showToast,
                error: (...args) => {
                    const formatted = args.map(arg => 
                        typeof arg === "object" ? JSON.stringify(arg) : String(arg)
                    ).join(" ");
                    capturedLogs.push(`Error: ${formatted}`);
                    console.error(...args);
                },
                warn: (...args) => {
                    const formatted = args.map(arg => 
                        typeof arg === "object" ? JSON.stringify(arg) : String(arg)
                    ).join(" ");
                    capturedLogs.push(`Warning: ${formatted}`);
                    console.warn(...args);
                },
                loadModule,
                loadModules,
                loadScript
            },
            target: litechatTarget,
            emit: (eventName, payload) => {
                window.dispatchEvent(new CustomEvent(eventName, { detail: payload }));
            }
        };

        // Execute the user's code after page load
        window.addEventListener('load', async () => {
            try {
                // User's code will be inserted here
                // Clear any previous content
litechat.target.replaceChildren();

async function createScrollShooter() {
    try {
        litechat.utils.log('info', 'üöÄ Starting 2D Scroll Shooter creation...');
        
        // Load Three.js
        const modules = await litechat.utils.loadModules([
            {
                url: 'https://unpkg.com/three@0.170.0/build/three.module.js',
                name: 'THREE',
                globalKey: 'THREE',
                importMap: {
                    "three": "https://unpkg.com/three@0.170.0/build/three.module.js"
                }
            }
        ]);

        const { THREE } = modules;
        
        // Create game container
        const gameContainer = document.createElement('div');
        gameContainer.className = 'p-4 bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900 rounded-xl shadow-2xl max-w-4xl mx-auto';
        
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        canvas.className = 'border-2 border-purple-400 rounded-lg shadow-lg';
        gameContainer.appendChild(canvas);
        
        // Add UI overlay
        const uiOverlay = document.createElement('div');
        uiOverlay.className = 'absolute top-4 left-4 text-white font-bold text-lg';
        uiOverlay.innerHTML = `
            <div class="bg-black/50 p-3 rounded-lg">
                <div>‚ù§Ô∏è Lives: <span id="lives">3</span></div>
                <div>üî´ Fire Rate: <span id="fireRate">100%</span></div>
                <div>üí• Bouncy: <span id="bouncy">0</span></div>
                <div>üî´ Guns: <span id="guns">1</span></div>
            </div>
        `;
        gameContainer.appendChild(uiOverlay);
        
        litechat.target.appendChild(gameContainer);

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a2a);
        
        const camera = new THREE.OrthographicCamera(-400, 400, 300, -300, 1, 1000);
        camera.position.z = 500;
        
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(800, 600);
        renderer.shadowMap.enabled = true;

        // Game state
        let gameState = {
            lives: 3,
            fireRate: 1.0,
            bouncyLevel: 0,
            gunLevel: 1,
            score: 0,
            wave: 1,
            keys: {},
            lastShot: 0
        };

        // Game objects
        const player = {
            x: 0,
            y: -250,
            width: 40,
            height: 40,
            speed: 5,
            mesh: null
        };

        const bullets = [];
        const enemies = [];
        const bonuses = [];
        const particles = [];

        // Create player mesh
        const playerGeometry = new THREE.BoxGeometry(40, 40, 10);
        const playerMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x00ff88,
            emissive: 0x00ff88,
            emissiveIntensity: 0.3
        });
        player.mesh = new THREE.Mesh(playerGeometry, playerMaterial);
        player.mesh.position.set(player.x, player.y, 0);
        scene.add(player.mesh);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 0, 100);
        scene.add(directionalLight);

        // Create background stars
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 200;
        const starPositions = new Float32Array(starCount * 3);
        
        for (let i = 0; i < starCount * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 1000;
            starPositions[i + 1] = (Math.random() - 0.5) * 1000;
            starPositions[i + 2] = -100 - Math.random() * 400;
        }
        
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const starMaterial = new THREE.PointsMaterial({ 
            color: 0xffffff, 
            size: 2,
            transparent: true,
            opacity: 0.8
        });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Helper functions
        function createBullet(x, y, dx, dy, bouncy = false) {
            const geometry = new THREE.SphereGeometry(5, 8, 8);
            const material = new THREE.MeshLambertMaterial({ 
                color: bouncy ? 0xff00ff : 0x00ffff,
                emissive: bouncy ? 0xff00ff : 0x00ffff,
                emissiveIntensity: 0.5
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, 10);
            scene.add(mesh);
            
            bullets.push({
                x, y, dx, dy, mesh, bouncy, bounces: 0
            });
        }

        function createEnemy(x, y, speed) {
            const colors = [0xff4444, 0xff8844, 0xffff44, 0x44ff44, 0x44ffff, 0x8844ff];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            const geometry = new THREE.BoxGeometry(30, 30, 15);
            const material = new THREE.MeshLambertMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.2
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, 0);
            scene.add(mesh);
            
            enemies.push({
                x, y, speed, mesh, health: gameState.wave
            });
        }

        function createBonus(x, y, type) {
            const colors = {
                fireRate: 0xff8800,
                bouncy: 0xff00ff,
                gun: 0x00ff00,
                life: 0xff0000
            };
            
            const icons = {
                fireRate: '‚ö°',
                bouncy: 'üí•',
                gun: 'üî´',
                life: '‚ù§Ô∏è'
            };
            
            const geometry = new THREE.SphereGeometry(15, 8, 8);
            const material = new THREE.MeshLambertMaterial({ 
                color: colors[type],
                emissive: colors[type],
                emissiveIntensity: 0.4
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, 5);
            scene.add(mesh);
            
            bonuses.push({
                x, y, type, mesh
            });
        }

        function createParticle(x, y, color) {
            const geometry = new THREE.SphereGeometry(3, 4, 4);
            const material = new THREE.MeshBasicMaterial({ color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, 20);
            scene.add(mesh);
            
            particles.push({
                x, y, dx: (Math.random() - 0.5) * 10,
                dy: (Math.random() - 0.5) * 10,
                life: 30, mesh
            });
        }

        function updateUI() {
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('fireRate').textContent = Math.round(gameState.fireRate * 100) + '%';
            document.getElementById('bouncy').textContent = gameState.bouncyLevel;
            document.getElementById('guns').textContent = gameState.gunLevel;
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.key.toLowerCase()] = true;
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.key.toLowerCase()] = false;
        });

        // Game loop
        let lastEnemySpawn = 0;
        let lastBonusSpawn = 0;

        function gameLoop() {
            const now = Date.now();
            
            // Move player
            if (gameState.keys['arrowleft'] && player.x > -380) player.x -= player.speed;
            if (gameState.keys['arrowright'] && player.x < 380) player.x += player.speed;
            if (gameState.keys['arrowup'] && player.y > -280) player.y -= player.speed;
            if (gameState.keys['arrowdown'] && player.y < 280) player.y += player.speed;
            
            player.mesh.position.set(player.x, player.y, 0);
            
            // Shoot bullets
            const shootInterval = 300 / gameState.fireRate;
            if (gameState.keys[' '] && now - gameState.lastShot > shootInterval) {
                const offsets = {
                    1: [[0, 20]],
                    2: [[-15, 20], [15, 20]],
                    3: [[-20, 20], [0, 25], [20, 20]]
                };
                
                offsets[gameState.gunLevel].forEach(([dx, dy]) => {
                    createBullet(
                        player.x + dx,
                        player.y + dy,
                        0, 8,
                        gameState.bouncyLevel > 0
                    );
                });
                
                gameState.lastShot = now;
            }
            
            // Update bullets
            bullets.forEach((bullet, index) => {
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
                bullet.mesh.position.set(bullet.x, bullet.y, 10);
                
                if (bullet.y > 350) {
                    scene.remove(bullet.mesh);
                    bullets.splice(index, 1);
                }
            });
            
            // Spawn enemies
            if (now - lastEnemySpawn > 2000 / Math.sqrt(gameState.wave)) {
                createEnemy(
                    (Math.random() - 0.5) * 700,
                    350,
                    2 + gameState.wave * 0.5
                );
                lastEnemySpawn = now;
            }
            
            // Spawn bonuses
            if (now - lastBonusSpawn > 8000) {
                const types = ['fireRate', 'bouncy', 'gun', 'life'];
                const type = types[Math.floor(Math.random() * types.length)];
                createBonus(
                    (Math.random() - 0.5) * 700,
                    Math.random() * 400 - 200,
                    type
                );
                lastBonusSpawn = now;
            }
            
            // Update enemies
            enemies.forEach((enemy, enemyIndex) => {
                enemy.y -= enemy.speed;
                enemy.mesh.position.set(enemy.x, enemy.y, 0);
                
                // Check collision with player
                if (Math.abs(enemy.x - player.x) < 35 && Math.abs(enemy.y - player.y) < 35) {
                    gameState.lives--;
                    updateUI();
                    
                    for (let i = 0; i < 10; i++) {
                        createParticle(enemy.x, enemy.y, 0xff0000);
                    }
                    
                    scene.remove(enemy.mesh);
                    enemies.splice(enemyIndex, 1);
                    
                    if (gameState.lives <= 0) {
                        alert('Game Over! Refresh to play again.');
                        return;
                    }
                }
                
                if (enemy.y < -350) {
                    scene.remove(enemy.mesh);
                    enemies.splice(enemyIndex, 1);
                }
            });
            
            // Update bonuses
            bonuses.forEach((bonus, index) => {
                bonus.y -= 1;
                bonus.mesh.position.set(bonus.x, bonus.y, 5);
                bonus.mesh.rotation.y += 0.05;
                
                // Check collision with player
                if (Math.abs(bonus.x - player.x) < 30 && Math.abs(bonus.y - player.y) < 30) {
                    switch (bonus.type) {
                        case 'fireRate':
                            gameState.fireRate = Math.min(gameState.fireRate * 1.1, 5);
                            break;
                        case 'bouncy':
                            gameState.bouncyLevel++;
                            break;
                        case 'gun':
                            gameState.gunLevel = Math.min(gameState.gunLevel + 1, 3);
                            break;
                        case 'life':
                            gameState.lives++;
                            break;
                    }
                    
                    updateUI();
                    
                    for (let i = 0; i < 8; i++) {
                        createParticle(bonus.x, bonus.y, 0xffff00);
                    }
                    
                    scene.remove(bonus.mesh);
                    bonuses.splice(index, 1);
                }
                
                if (bonus.y < -350) {
                    scene.remove(bonus.mesh);
                    bonuses.splice(index, 1);
                }
            });
            
            // Update particles
            particles.forEach((particle, index) => {
                particle.x += particle.dx;
                particle.y += particle.dy;
                particle.dx *= 0.98;
                particle.dy *= 0.98;
                particle.mesh.position.set(particle.x, particle.y, 20);
                particle.life--;
                
                if (particle.life <= 0) {
                    scene.remove(particle.mesh);
                    particles.splice(index, 1);
                }
            });
            
            // Check bullet-enemy collisions
            bullets.forEach((bullet, bulletIndex) => {
                enemies.forEach((enemy, enemyIndex) => {
                    if (Math.abs(bullet.x - enemy.x) < 20 && Math.abs(bullet.y - enemy.y) < 20) {
                        enemy.health--;
                        
                        if (enemy.health <= 0) {
                            for (let i = 0; i < 8; i++) {
                                createParticle(enemy.x, enemy.y, enemy.mesh.material.color.getHex());
                            }
                            
                            scene.remove(enemy.mesh);
                            enemies.splice(enemyIndex, 1);
                            gameState.score += 10;
                            
                            // Bouncy bullet logic
                            if (bullet.bouncy && bullet.bounces < gameState.bouncyLevel) {
                                bullet.bounces++;
                                bullet.dx = (Math.random() - 0.5) * 8;
                                bullet.dy = -Math.abs(bullet.dy);
                                return;
                            }
                        }
                        
                        scene.remove(bullet.mesh);
                        bullets.splice(bulletIndex, 1);
                    }
                });
            });
            
            // Update wave
            if (enemies.length === 0 && now - lastEnemySpawn > 5000) {
                gameState.wave++;
            }
            
            // Animate stars
            stars.rotation.y += 0.0005;
            
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }
        
        updateUI();
        gameLoop();
        
        // Instructions
        const instructions = document.createElement('div');
        instructions.className = 'text-center text-white mt-4 text-sm';
        instructions.innerHTML = `
            Use ARROW KEYS to move ‚Ä¢ SPACE to shoot ‚Ä¢ Collect colorful bonuses!<br>
            Red = Extra Life ‚Ä¢ Orange = Faster Fire ‚Ä¢ Purple = Bouncy Bullets ‚Ä¢ Green = More Guns
        `;
        gameContainer.appendChild(instructions);
        
        litechat.utils.log('info', 'üéÆ Game started! Use arrow keys to move and space to shoot');
        
    } catch (error) {
        litechat.utils.log('error', '‚ùå Failed to create game:', error.message);
    }
}

createScrollShooter();

            } catch (error) {
                console.error('Execution error:', error);
                const errorDiv = document.createElement('div');
                errorDiv.className = 'p-4 text-red-600 bg-red-100 border border-red-200 rounded-md';
                errorDiv.textContent = `Error: ${error.message}`;
                litechatTarget.appendChild(errorDiv);
            }
        });
    </script>
</body>
</html>