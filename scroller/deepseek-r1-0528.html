<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>deepseek-r1-0528 - LiteChat Race Result</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #f0f2f5; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .tab-button { transition: all 0.2s ease-in-out; border-bottom: 2px solid transparent; }
        .tab-button.active { border-bottom-color: #6366f1; color: #4f46e5; background-color: #e0e7ff; }
        .dark .tab-button.active { border-bottom-color: #818cf8; color: #a5b4fc; background-color: #374151; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 p-4 sm:p-6 md:p-8">
    <div class="max-w-7xl mx-auto container bg-white dark:bg-gray-800 rounded-2xl shadow-lg overflow-hidden">
        <div class="header bg-gradient-to-r from-violet-600 to-indigo-600 text-white p-6 sm:p-8 text-center">
            <h1 class="text-3xl sm:text-4xl font-bold mb-2">🚀 deepseek-r1-0528</h1>
            <p class="text-indigo-200">LiteChat Race Result</p>
        </div>
        
        <div class="p-4 sm:p-6">
            <div class="border-b border-gray-200 dark:border-gray-700 mb-4">
                <nav class="-mb-px flex space-x-4" aria-label="Tabs">
                    <button class="tab-button active text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 whitespace-nowrap py-3 px-4 font-medium text-sm rounded-t-md" data-tab="preview">Live Preview</button>
                    <button class="tab-button text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 whitespace-nowrap py-3 px-4 font-medium text-sm rounded-t-md" data-tab="raw">Raw Response</button>
                </nav>
            </div>

            <div id="preview" class="tab-content active">
                <div id="litechat-target" class="w-full min-h-[600px] bg-gray-50 dark:bg-gray-700/50 rounded-lg p-4 border border-gray-200 dark:border-gray-600"></div>
            </div>

            <div id="raw" class="tab-content">
                <div class="w-full min-h-[600px] bg-gray-900 text-white rounded-lg p-4 overflow-x-auto font-mono">
                    <pre class="whitespace-pre-wrap text-sm"><code>Here's a colorful 3D-style scroll shooter with bonus drops, implemented using Three.js:

```runjs
// Main game module
(async () =&gt; {
    try {
        // Load Three.js modules
        const { THREE, OrbitControls } = await litechat.utils.loadModules([
            {
                url: 'https://unpkg.com/three@0.170.0/build/three.module.js',
                name: 'THREE',
                globalKey: 'THREE',
                importMap: {
                    "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
                }
            },
            {
                url: 'https://unpkg.com/three@0.170.0/examples/jsm/controls/OrbitControls.js',
                name: 'OrbitControls',
                globalKey: 'OrbitControls',
                dependencies: ['THREE']
            }
        ]);

        // Clear previous content
        litechat.target.replaceChildren();
        
        // Game constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        const PLAYER_SPEED = 0.2;
        const BASE_FIRE_RATE = 500; // ms between shots
        const ENEMY_SPAWN_RATE = 1000; // ms
        const BONUS_DROP_CHANCE = 0.2; // 20% chance

        // Game state
        let gameState = {
            score: 0,
            lives: 3,
            fireRate: BASE_FIRE_RATE,
            lastShot: 0,
            bouncyLevel: 0,
            gunLevel: 1,
            enemySpeed: 0.05,
            activeBonuses: {},
            enemies: [],
            playerBullets: [],
            bonuses: [],
            isGameOver: false
        };

        // Create container for game
        const container = document.createElement('div');
        container.className = 'relative w-full h-full';
        container.style.width = `${GAME_WIDTH}px`;
        container.style.height = `${GAME_HEIGHT}px`;
        container.style.backgroundColor = '#1a1a2e';
        container.style.overflow = 'hidden';
        container.style.borderRadius = '0.5rem';
        container.style.boxShadow = '0 0 20px rgba(135, 206, 235, 0.3)';

        // UI elements
        const uiContainer = document.createElement('div');
        uiContainer.className = 'absolute top-0 left-0 w-full p-4 flex justify-between items-center';
        uiContainer.style.zIndex = '10';
        
        const scoreDisplay = document.createElement('div');
        scoreDisplay.className = 'text-white text-lg font-bold';
        scoreDisplay.textContent = `Score: ${gameState.score}`;
        
        const livesDisplay = document.createElement('div');
        livesDisplay.className = 'text-white text-lg font-bold';
        livesDisplay.textContent = `Lives: ${gameState.lives}`;
        
        const bonusDisplay = document.createElement('div');
        bonusDisplay.className = 'text-white text-sm';
        bonusDisplay.innerHTML = 'Bonuses: &lt;span id="bonusList"&gt;None&lt;/span&gt;';
        
        uiContainer.appendChild(scoreDisplay);
        uiContainer.appendChild(livesDisplay);
        uiContainer.appendChild(bonusDisplay);
        container.appendChild(uiContainer);

        // Create canvas for Three.js
        const canvas = document.createElement('canvas');
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;
        container.appendChild(canvas);
        litechat.target.appendChild(container);

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 20, 100);

        const camera = new THREE.PerspectiveCamera(
            75, 
            GAME_WIDTH / GAME_HEIGHT, 
            0.1, 
            1000
        );
        camera.position.set(0, 8, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(GAME_WIDTH, GAME_HEIGHT);
        renderer.shadowMap.enabled = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffddaa, 1);
        sunLight.position.set(10, 20, 15);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // Stars background
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 0.8
        });
        
        const starsVertices = [];
        for (let i = 0; i &lt; 1000; i++) {
            starsVertices.push(
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200
            );
        }
        
        starsGeometry.setAttribute(
            'position', 
            new THREE.Float32BufferAttribute(starsVertices, 3)
        );
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Player ship
        const playerGeometry = new THREE.ConeGeometry(0.8, 2, 8);
        const playerMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x4deeea,
            emissive: 0x0a3a5f,
            shininess: 100
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = -4;
        player.rotation.x = Math.PI;
        player.castShadow = true;
        scene.add(player);

        // Game objects arrays
        const enemies = [];
        const bullets = [];
        const bonuses = [];

        // Create an enemy
        function createEnemy() {
            const colors = [
                0xff6b6b, 0xffd166, 0x06d6a0, 
                0x118ab2, 0xef476f, 0xffd166
            ];
            
            const geometry = new THREE.ConeGeometry(0.8, 2, 6);
            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                emissive: 0x111111,
                shininess: 60
            });
            
            const enemy = new THREE.Mesh(geometry, material);
            enemy.position.x = (Math.random() - 0.5) * 12;
            enemy.position.z = 20;
            enemy.rotation.x = Math.PI;
            enemy.castShadow = true;
            enemy.userData = { health: 1 };
            scene.add(enemy);
            enemies.push(enemy);
            return enemy;
        }

        // Create bullet
        function createBullet() {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshPhongMaterial({
                color: 0x4deeea,
                emissive: 0x0a3a5f
            });
            
            const bullet = new THREE.Mesh(geometry, material);
            bullet.position.copy(player.position);
            bullet.position.y += 0.5;
            bullet.castShadow = true;
            bullet.userData = {
                bounceCount: gameState.bouncyLevel,
                direction: new THREE.Vector3(0, 0, 1)
            };
            scene.add(bullet);
            bullets.push(bullet);
            return bullet;
        }

        // Create bonus
        function createBonus(position, type) {
            const types = {
                fireRate: { color: 0xf72585, symbol: '⚡' },
                bouncy: { color: 0x4cc9f0, symbol: '🔵' },
                gun: { color: 0x4361ee, symbol: '🔫' },
                life: { color: 0x06d6a0, symbol: '❤️' }
            };
            
            const geometry = new THREE.IcosahedronGeometry(0.6, 0);
            const material = new THREE.MeshPhongMaterial({
                color: types[type].color,
                emissive: types[type].color,
                emissiveIntensity: 0.3
            });
            
            const bonus = new THREE.Mesh(geometry, material);
            bonus.position.copy(position);
            bonus.castShadow = true;
            bonus.userData = { type, symbol: types[type].symbol };
            scene.add(bonus);
            bonuses.push(bonus);
            return bonus;
        }

        // Handle keyboard input
        const keys = {};
        window.addEventListener('keydown', (e) =&gt; {
            keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) =&gt; {
            keys[e.key] = false;
        });

        // Handle bonus collection
        function collectBonus(bonus) {
            const { type } = bonus.userData;
            gameState.activeBonuses[type] = (gameState.activeBonuses[type] || 0) + 1;
            
            switch(type) {
                case 'fireRate':
                    gameState.fireRate = BASE_FIRE_RATE * (1 - 0.1 * gameState.activeBonuses[type]);
                    break;
                case 'bouncy':
                    gameState.bouncyLevel = gameState.activeBonuses[type];
                    break;
                case 'gun':
                    gameState.gunLevel = Math.min(3, gameState.activeBonuses[type] + 1);
                    break;
                case 'life':
                    gameState.lives++;
                    break;
            }
            
            // Update UI
            const bonusItems = Object.entries(gameState.activeBonuses)
                .map(([key, val]) =&gt; `${key}: ${val}`)
                .join(', ');
            document.getElementById('bonusList').textContent = bonusItems || 'None';
            
            // Remove bonus
            scene.remove(bonus);
            bonuses.splice(bonuses.indexOf(bonus), 1);
        }

        // Handle collisions
        function checkCollisions() {
            // Bullet-enemy collisions
            for (let i = bullets.length - 1; i &gt;= 0; i--) {
                for (let j = enemies.length - 1; j &gt;= 0; j--) {
                    const bullet = bullets[i];
                    const enemy = enemies[j];
                    
                    if (bullet.position.distanceTo(enemy.position) &lt; 1.5) {
                        scene.remove(enemy);
                        enemies.splice(j, 1);
                        
                        // Chance to drop bonus
                        if (Math.random() &lt; BONUS_DROP_CHANCE) {
                            const bonusTypes = ['fireRate', 'bouncy', 'gun', 'life'];
                            const bonusType = bonusTypes[Math.floor(Math.random() * bonusTypes.length)];
                            createBonus(enemy.position.clone(), bonusType);
                        }
                        
                        // Handle bullet bounce
                        if (bullet.userData.bounceCount &gt; 0) {
                            bullet.userData.bounceCount--;
                            bullet.userData.direction.z *= -1;
                        } else {
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                        }
                        
                        gameState.score += 100;
                        scoreDisplay.textContent = `Score: ${gameState.score}`;
                        break;
                    }
                }
            }
            
            // Player-enemy collisions
            for (let i = enemies.length - 1; i &gt;= 0; i--) {
                if (player.position.distanceTo(enemies[i].position) &lt; 1.8) {
                    scene.remove(enemies[i]);
                    enemies.splice(i, 1);
                    gameState.lives--;
                    livesDisplay.textContent = `Lives: ${gameState.lives}`;
                    
                    if (gameState.lives &lt;= 0) {
                        gameState.isGameOver = true;
                    }
                }
            }
            
            // Player-bonus collisions
            for (let i = bonuses.length - 1; i &gt;= 0; i--) {
                if (player.position.distanceTo(bonuses[i].position) &lt; 1.2) {
                    collectBonus(bonuses[i]);
                }
            }
        }

        // Game loop
        let lastSpawn = 0;
        function animate(time) {
            if (gameState.isGameOver) {
                const gameOver = document.createElement('div');
                gameOver.className = 'absolute inset-0 flex items-center justify-center text-white text-3xl font-bold';
                gameOver.textContent = 'GAME OVER!';
                container.appendChild(gameOver);
                return;
            }

            requestAnimationFrame(animate);
            
            // Move player
            if (keys['ArrowLeft'] || keys['a']) {
                player.position.x = Math.max(-8, player.position.x - PLAYER_SPEED);
            }
            if (keys['ArrowRight'] || keys['d']) {
                player.position.x = Math.min(8, player.position.x + PLAYER_SPEED);
            }
            if (keys['ArrowUp'] || keys['w']) {
                player.position.z = Math.min(0, player.position.z + PLAYER_SPEED);
            }
            if (keys['ArrowDown'] || keys['s']) {
                player.position.z = Math.max(-8, player.position.z - PLAYER_SPEED);
            }
            
            // Shooting
            if (keys[' '] && time - gameState.lastShot &gt; gameState.fireRate) {
                gameState.lastShot = time;
                
                // Create bullets based on gun level
                const positions = [
                    { x: 0, z: 0 }
                ];
                
                if (gameState.gunLevel &gt;= 2) {
                    positions.push({ x: -0.7, z: -0.5 }, { x: 0.7, z: -0.5 });
                }
                
                if (gameState.gunLevel &gt;= 3) {
                    positions.push({ x: -1.2, z: -1 }, { x: 1.2, z: -1 });
                }
                
                positions.forEach(pos =&gt; {
                    const bullet = createBullet();
                    bullet.position.x = player.position.x + pos.x;
                    bullet.position.z = player.position.z + pos.z;
                });
            }
            
            // Spawn enemies
            if (time - lastSpawn &gt; ENEMY_SPAWN_RATE) {
                lastSpawn = time;
                createEnemy();
            }
            
            // Update enemies
            for (let i = enemies.length - 1; i &gt;= 0; i--) {
                enemies[i].position.z -= gameState.enemySpeed;
                
                // Remove if out of bounds
                if (enemies[i].position.z &lt; -15) {
                    scene.remove(enemies[i]);
                    enemies.splice(i, 1);
                }
            }
            
            // Update bullets
            for (let i = bullets.length - 1; i &gt;= 0; i--) {
                bullets[i].position.add(bullets[i].userData.direction);
                
                // Remove if out of bounds
                if (bullets[i].position.z &gt; 25) {
                    scene.remove(bullets[i]);
                    bullets.splice(i, 1);
                }
            }
            
            // Update bonuses
            for (let i = bonuses.length - 1; i &gt;= 0; i--) {
                bonuses[i].position.z -= 0.05;
                
                // Add rotation effect
                bonuses[i].rotation.x += 0.02;
                bonuses[i].rotation.y += 0.03;
                
                // Remove if out of bounds
                if (bonuses[i].position.z &lt; -15) {
                    scene.remove(bonuses[i]);
                    bonuses.splice(i, 1);
                }
            }
            
            // Rotate player for visual effect
            player.rotation.z = Math.sin(time * 0.005) * 0.2;
            
            // Gradually increase difficulty
            gameState.enemySpeed += 0.0001;
            
            checkCollisions();
            renderer.render(scene, camera);
        }

        // Start the game
        animate(0);
        
    } catch (error) {
        litechat.utils.log('error', 'Game error: ' + error.message);
        const errorDiv = document.createElement('div');
        errorDiv.className = 'p-4 text-red-500 bg-red-50 rounded-md';
        errorDiv.textContent = 'Error: ' + error.message;
        litechat.target.appendChild(errorDiv);
    }
})();
```

### Game Features:

1. **Player Ship**: 
   - Move with arrow keys or WASD
   - Blue glowing cone ship with smooth rotation

2. **Enemies**:
   - Colorful cone-shaped enemies that move toward the player
   - Speed increases over time
   - Destroyed enemies have 20% chance to drop bonuses

3. **Bonus System**:
   - ⚡ Fire Rate: +10% fire speed per bonus
   - 🔵 Bouncy: Bullets bounce on enemy hit
   - 🔫 Gun: Upgrade weapon (1 → 2 → 3 guns)
   - ❤️ Life: Extra life

4. **Visuals**:
   - Starry nebula background
   - Soft blue lighting
   - Smooth shadows and glow effects
   - Responsive UI showing score, lives and active bonuses

5. **Controls**:
   - Space bar to shoot
   - Arrow keys/WASD to move

The game has a cozy space theme with vibrant colors and smooth animations. Difficulty gradually increases as enemies get faster over time. Collect bonuses to enhance your ship's capabilities and survive longer!

Would you like me to explain any part of the implementation in more detail?</code></pre>
                </div>
            </div>
        </div>

        <div class="footer bg-gray-50 dark:bg-gray-800/50 p-4 border-t border-gray-200 dark:border-gray-700 text-center text-sm text-gray-500 dark:text-gray-400">
            Generated by <strong>LiteChat</strong> • <a href="./index.html" class="text-indigo-600 dark:text-indigo-400 hover:underline">Back to Main Page</a>
        </div>
    </div>

    <script type="module">
        // Tab switching logic
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                const tabId = button.dataset.tab;
                tabContents.forEach(content => content.id === tabId ? content.classList.add('active') : content.classList.remove('active'));
            });
        });
        
        // --- LITECHAT MOCK API ---
        
        const litechatTarget = document.getElementById('litechat-target');
        async function loadModules(moduleConfigs) {
            const loadedModules = {};
            const loadPromises = {};
            const globalImportMap = {};
            moduleConfigs.forEach(config => {
                if (config.importMap) Object.assign(globalImportMap, config.importMap);
            });
            const existingMap = document.querySelector('script[type="importmap"]');
            if (existingMap) existingMap.remove();
            if (Object.keys(globalImportMap).length > 0) {
                const mapScript = document.createElement('script');
                mapScript.type = 'importmap';
                mapScript.textContent = JSON.stringify({ imports: globalImportMap });
                document.head.appendChild(mapScript);
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            const loadSingleModule = async (config) => {
                const key = config.globalKey || config.name;
                if (window[key]) return window[key];
                if (key in loadPromises) return loadPromises[key];
                if (config.dependencies) {
                    await Promise.all(config.dependencies.map(depKey => {
                        const depModule = moduleConfigs.find(m => (m.globalKey || m.name) === depKey);
                        if (depModule) return loadSingleModule(depModule);
                        return Promise.resolve();
                    }));
                }
                loadPromises[key] = (async () => {
                    try {
                        const module = await import(config.url);
                        window[key] = module;
                        loadedModules[key] = module;
                        return module;
                    } catch (error) {
                        console.error(`Error loading module ${config.name}:`, error);
                        throw error;
                    }
                })();
                return loadPromises[key];
            };
            await Promise.all(moduleConfigs.map(config => loadSingleModule(config)));
            return loadedModules;
        }
        window.litechat = {
            utils: {
                log: (...args) => console.log(...args),
                toast: (message) => alert(message),
                error: (...args) => console.error(...args),
                warn: (...args) => console.warn(...args),
                loadModules,
                loadModule: async (url, name, key, importMap) => (await loadModules([{url, name, globalKey: key, importMap}]))[key || name],
            },
            target: litechatTarget,
            emit: (eventName, payload) => window.dispatchEvent(new CustomEvent(eventName, { detail: payload })),
        };
    

        // --- EXECUTE CODE ---
        try {
            // Inject the extracted runjs code here
            // Main game module
(async () => {
    try {
        // Load Three.js modules
        const { THREE, OrbitControls } = await litechat.utils.loadModules([
            {
                url: 'https://unpkg.com/three@0.170.0/build/three.module.js',
                name: 'THREE',
                globalKey: 'THREE',
                importMap: {
                    "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
                    "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/"
                }
            },
            {
                url: 'https://unpkg.com/three@0.170.0/examples/jsm/controls/OrbitControls.js',
                name: 'OrbitControls',
                globalKey: 'OrbitControls',
                dependencies: ['THREE']
            }
        ]);

        // Clear previous content
        litechat.target.replaceChildren();
        
        // Game constants
        const GAME_WIDTH = 800;
        const GAME_HEIGHT = 600;
        const PLAYER_SPEED = 0.2;
        const BASE_FIRE_RATE = 500; // ms between shots
        const ENEMY_SPAWN_RATE = 1000; // ms
        const BONUS_DROP_CHANCE = 0.2; // 20% chance

        // Game state
        let gameState = {
            score: 0,
            lives: 3,
            fireRate: BASE_FIRE_RATE,
            lastShot: 0,
            bouncyLevel: 0,
            gunLevel: 1,
            enemySpeed: 0.05,
            activeBonuses: {},
            enemies: [],
            playerBullets: [],
            bonuses: [],
            isGameOver: false
        };

        // Create container for game
        const container = document.createElement('div');
        container.className = 'relative w-full h-full';
        container.style.width = `${GAME_WIDTH}px`;
        container.style.height = `${GAME_HEIGHT}px`;
        container.style.backgroundColor = '#1a1a2e';
        container.style.overflow = 'hidden';
        container.style.borderRadius = '0.5rem';
        container.style.boxShadow = '0 0 20px rgba(135, 206, 235, 0.3)';

        // UI elements
        const uiContainer = document.createElement('div');
        uiContainer.className = 'absolute top-0 left-0 w-full p-4 flex justify-between items-center';
        uiContainer.style.zIndex = '10';
        
        const scoreDisplay = document.createElement('div');
        scoreDisplay.className = 'text-white text-lg font-bold';
        scoreDisplay.textContent = `Score: ${gameState.score}`;
        
        const livesDisplay = document.createElement('div');
        livesDisplay.className = 'text-white text-lg font-bold';
        livesDisplay.textContent = `Lives: ${gameState.lives}`;
        
        const bonusDisplay = document.createElement('div');
        bonusDisplay.className = 'text-white text-sm';
        bonusDisplay.innerHTML = 'Bonuses: <span id="bonusList">None</span>';
        
        uiContainer.appendChild(scoreDisplay);
        uiContainer.appendChild(livesDisplay);
        uiContainer.appendChild(bonusDisplay);
        container.appendChild(uiContainer);

        // Create canvas for Three.js
        const canvas = document.createElement('canvas');
        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;
        container.appendChild(canvas);
        litechat.target.appendChild(container);

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        scene.fog = new THREE.Fog(0x1a1a2e, 20, 100);

        const camera = new THREE.PerspectiveCamera(
            75, 
            GAME_WIDTH / GAME_HEIGHT, 
            0.1, 
            1000
        );
        camera.position.set(0, 8, 15);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(GAME_WIDTH, GAME_HEIGHT);
        renderer.shadowMap.enabled = true;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffddaa, 1);
        sunLight.position.set(10, 20, 15);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // Stars background
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 0.8
        });
        
        const starsVertices = [];
        for (let i = 0; i < 1000; i++) {
            starsVertices.push(
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200,
                (Math.random() - 0.5) * 200
            );
        }
        
        starsGeometry.setAttribute(
            'position', 
            new THREE.Float32BufferAttribute(starsVertices, 3)
        );
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Player ship
        const playerGeometry = new THREE.ConeGeometry(0.8, 2, 8);
        const playerMaterial = new THREE.MeshPhongMaterial({ 
            color: 0x4deeea,
            emissive: 0x0a3a5f,
            shininess: 100
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.position.y = -4;
        player.rotation.x = Math.PI;
        player.castShadow = true;
        scene.add(player);

        // Game objects arrays
        const enemies = [];
        const bullets = [];
        const bonuses = [];

        // Create an enemy
        function createEnemy() {
            const colors = [
                0xff6b6b, 0xffd166, 0x06d6a0, 
                0x118ab2, 0xef476f, 0xffd166
            ];
            
            const geometry = new THREE.ConeGeometry(0.8, 2, 6);
            const material = new THREE.MeshPhongMaterial({
                color: colors[Math.floor(Math.random() * colors.length)],
                emissive: 0x111111,
                shininess: 60
            });
            
            const enemy = new THREE.Mesh(geometry, material);
            enemy.position.x = (Math.random() - 0.5) * 12;
            enemy.position.z = 20;
            enemy.rotation.x = Math.PI;
            enemy.castShadow = true;
            enemy.userData = { health: 1 };
            scene.add(enemy);
            enemies.push(enemy);
            return enemy;
        }

        // Create bullet
        function createBullet() {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshPhongMaterial({
                color: 0x4deeea,
                emissive: 0x0a3a5f
            });
            
            const bullet = new THREE.Mesh(geometry, material);
            bullet.position.copy(player.position);
            bullet.position.y += 0.5;
            bullet.castShadow = true;
            bullet.userData = {
                bounceCount: gameState.bouncyLevel,
                direction: new THREE.Vector3(0, 0, 1)
            };
            scene.add(bullet);
            bullets.push(bullet);
            return bullet;
        }

        // Create bonus
        function createBonus(position, type) {
            const types = {
                fireRate: { color: 0xf72585, symbol: '⚡' },
                bouncy: { color: 0x4cc9f0, symbol: '🔵' },
                gun: { color: 0x4361ee, symbol: '🔫' },
                life: { color: 0x06d6a0, symbol: '❤️' }
            };
            
            const geometry = new THREE.IcosahedronGeometry(0.6, 0);
            const material = new THREE.MeshPhongMaterial({
                color: types[type].color,
                emissive: types[type].color,
                emissiveIntensity: 0.3
            });
            
            const bonus = new THREE.Mesh(geometry, material);
            bonus.position.copy(position);
            bonus.castShadow = true;
            bonus.userData = { type, symbol: types[type].symbol };
            scene.add(bonus);
            bonuses.push(bonus);
            return bonus;
        }

        // Handle keyboard input
        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Handle bonus collection
        function collectBonus(bonus) {
            const { type } = bonus.userData;
            gameState.activeBonuses[type] = (gameState.activeBonuses[type] || 0) + 1;
            
            switch(type) {
                case 'fireRate':
                    gameState.fireRate = BASE_FIRE_RATE * (1 - 0.1 * gameState.activeBonuses[type]);
                    break;
                case 'bouncy':
                    gameState.bouncyLevel = gameState.activeBonuses[type];
                    break;
                case 'gun':
                    gameState.gunLevel = Math.min(3, gameState.activeBonuses[type] + 1);
                    break;
                case 'life':
                    gameState.lives++;
                    break;
            }
            
            // Update UI
            const bonusItems = Object.entries(gameState.activeBonuses)
                .map(([key, val]) => `${key}: ${val}`)
                .join(', ');
            document.getElementById('bonusList').textContent = bonusItems || 'None';
            
            // Remove bonus
            scene.remove(bonus);
            bonuses.splice(bonuses.indexOf(bonus), 1);
        }

        // Handle collisions
        function checkCollisions() {
            // Bullet-enemy collisions
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const bullet = bullets[i];
                    const enemy = enemies[j];
                    
                    if (bullet.position.distanceTo(enemy.position) < 1.5) {
                        scene.remove(enemy);
                        enemies.splice(j, 1);
                        
                        // Chance to drop bonus
                        if (Math.random() < BONUS_DROP_CHANCE) {
                            const bonusTypes = ['fireRate', 'bouncy', 'gun', 'life'];
                            const bonusType = bonusTypes[Math.floor(Math.random() * bonusTypes.length)];
                            createBonus(enemy.position.clone(), bonusType);
                        }
                        
                        // Handle bullet bounce
                        if (bullet.userData.bounceCount > 0) {
                            bullet.userData.bounceCount--;
                            bullet.userData.direction.z *= -1;
                        } else {
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                        }
                        
                        gameState.score += 100;
                        scoreDisplay.textContent = `Score: ${gameState.score}`;
                        break;
                    }
                }
            }
            
            // Player-enemy collisions
            for (let i = enemies.length - 1; i >= 0; i--) {
                if (player.position.distanceTo(enemies[i].position) < 1.8) {
                    scene.remove(enemies[i]);
                    enemies.splice(i, 1);
                    gameState.lives--;
                    livesDisplay.textContent = `Lives: ${gameState.lives}`;
                    
                    if (gameState.lives <= 0) {
                        gameState.isGameOver = true;
                    }
                }
            }
            
            // Player-bonus collisions
            for (let i = bonuses.length - 1; i >= 0; i--) {
                if (player.position.distanceTo(bonuses[i].position) < 1.2) {
                    collectBonus(bonuses[i]);
                }
            }
        }

        // Game loop
        let lastSpawn = 0;
        function animate(time) {
            if (gameState.isGameOver) {
                const gameOver = document.createElement('div');
                gameOver.className = 'absolute inset-0 flex items-center justify-center text-white text-3xl font-bold';
                gameOver.textContent = 'GAME OVER!';
                container.appendChild(gameOver);
                return;
            }

            requestAnimationFrame(animate);
            
            // Move player
            if (keys['ArrowLeft'] || keys['a']) {
                player.position.x = Math.max(-8, player.position.x - PLAYER_SPEED);
            }
            if (keys['ArrowRight'] || keys['d']) {
                player.position.x = Math.min(8, player.position.x + PLAYER_SPEED);
            }
            if (keys['ArrowUp'] || keys['w']) {
                player.position.z = Math.min(0, player.position.z + PLAYER_SPEED);
            }
            if (keys['ArrowDown'] || keys['s']) {
                player.position.z = Math.max(-8, player.position.z - PLAYER_SPEED);
            }
            
            // Shooting
            if (keys[' '] && time - gameState.lastShot > gameState.fireRate) {
                gameState.lastShot = time;
                
                // Create bullets based on gun level
                const positions = [
                    { x: 0, z: 0 }
                ];
                
                if (gameState.gunLevel >= 2) {
                    positions.push({ x: -0.7, z: -0.5 }, { x: 0.7, z: -0.5 });
                }
                
                if (gameState.gunLevel >= 3) {
                    positions.push({ x: -1.2, z: -1 }, { x: 1.2, z: -1 });
                }
                
                positions.forEach(pos => {
                    const bullet = createBullet();
                    bullet.position.x = player.position.x + pos.x;
                    bullet.position.z = player.position.z + pos.z;
                });
            }
            
            // Spawn enemies
            if (time - lastSpawn > ENEMY_SPAWN_RATE) {
                lastSpawn = time;
                createEnemy();
            }
            
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].position.z -= gameState.enemySpeed;
                
                // Remove if out of bounds
                if (enemies[i].position.z < -15) {
                    scene.remove(enemies[i]);
                    enemies.splice(i, 1);
                }
            }
            
            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].position.add(bullets[i].userData.direction);
                
                // Remove if out of bounds
                if (bullets[i].position.z > 25) {
                    scene.remove(bullets[i]);
                    bullets.splice(i, 1);
                }
            }
            
            // Update bonuses
            for (let i = bonuses.length - 1; i >= 0; i--) {
                bonuses[i].position.z -= 0.05;
                
                // Add rotation effect
                bonuses[i].rotation.x += 0.02;
                bonuses[i].rotation.y += 0.03;
                
                // Remove if out of bounds
                if (bonuses[i].position.z < -15) {
                    scene.remove(bonuses[i]);
                    bonuses.splice(i, 1);
                }
            }
            
            // Rotate player for visual effect
            player.rotation.z = Math.sin(time * 0.005) * 0.2;
            
            // Gradually increase difficulty
            gameState.enemySpeed += 0.0001;
            
            checkCollisions();
            renderer.render(scene, camera);
        }

        // Start the game
        animate(0);
        
    } catch (error) {
        litechat.utils.log('error', 'Game error: ' + error.message);
        const errorDiv = document.createElement('div');
        errorDiv.className = 'p-4 text-red-500 bg-red-50 rounded-md';
        errorDiv.textContent = 'Error: ' + error.message;
        litechat.target.appendChild(errorDiv);
    }
})();
        } catch (error) {
            console.error('Execution error:', error);
            const errorDiv = document.createElement('div');
            errorDiv.className = 'p-4 text-red-600 bg-red-100 border border-red-200 rounded-md';
            errorDiv.textContent = 'Execution Error: ' + error.message;
            document.getElementById('litechat-target').appendChild(errorDiv);
        }
    </script>
</body>
</html>